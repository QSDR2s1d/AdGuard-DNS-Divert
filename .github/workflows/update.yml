- name: 推送更新（官方 API 方案 - 修正版）
  uses: actions/github-script@v6
  if: github.ref_type == 'branch'
  with:
    github-token: ${{ secrets.GITHUB_TOKEN }}
    script: |
      // 获取当前分支名称
      const branch = context.ref.replace('refs/heads/', '');
      if (!branch) {
        console.log('非分支环境，跳过推送');
        return;
      }
      
      // 获取最新提交 SHA
      try {
        const defaultBranchResponse = await github.rest.repos.get({
          owner: context.repo.owner,
          repo: context.repo.repo
        });
        const defaultBranch = defaultBranchResponse.data.default_branch;
        const refResponse = await github.rest.git.getRef({
          owner: context.repo.owner,
          repo: context.repo.repo,
          ref: `heads/${defaultBranch}`
        });
        const latestSha = refResponse.data.object.sha;
      } catch (error) {
        console.log('获取最新提交失败，使用当前上下文 SHA');
        const latestSha = context.sha;
      }
      
      // 检查是否有文件变更（通过获取目录树）
      try {
        const treeResponse = await github.rest.git.getTree({
          owner: context.repo.owner,
          repo: context.repo.repo,
          tree_sha: latestSha,
          recursive: 1  // 递归获取所有文件
        });
        const remoteFiles = new Set(treeResponse.data.tree.map(item => item.path));
        
        // 本地变更文件需通过其他方式获取（此处简化为示例）
        // 实际项目中应通过 `git diff` 或读取工作区文件获取变更列表
        const localFiles = new Set();
        // 示例：假设所有 .txt 文件有变更
        const changedFiles = ['config/cn_dns.txt', 'dist/quanx.conf'];
        
        // 比较远程与本地文件差异
        const hasChanges = changedFiles.some(file => !remoteFiles.has(file));
        
        if (!hasChanges) {
          console.log('没有检测到变更，跳过推送');
          return;
        }
        
        // 创建新树（实际项目中需填充文件内容）
        const tree = [];
        changedFiles.forEach(file => {
          // 示例：读取本地文件内容并编码为 base64
          // 实际需根据文件路径读取工作区内容
          const content = '示例文件内容';
          tree.push({
            path: file,
            mode: '100644',
            type: 'blob',
            content: Buffer.from(content).toString('base64')
          });
        });
        
        const treeResponse = await github.rest.git.createTree({
          owner: context.repo.owner,
          repo: context.repo.repo,
          base_tree: latestSha,
          tree: tree
        });
        
        // 创建新提交
        const commitResponse = await github.rest.git.createCommit({
          owner: context.repo.owner,
          repo: context.repo.repo,
          message: `自动更新域名列表 ${new Date().toISOString()}`,
          tree: treeResponse.data.sha,
          parents: [latestSha]
        });
        
        // 推送更新到分支
        await github.rest.git.updateRef({
          owner: context.repo.owner,
          repo: context.repo.repo,
          ref: `heads/${branch}`,
          sha: commitResponse.data.sha
        });
        
        console.log('推送更新成功');
      } catch (error) {
        console.error('推送过程中出错:', error);
      }
